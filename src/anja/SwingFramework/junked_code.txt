



Various bits and pieces of unused code from the framework components.
WARNING: This is a PILE of code, completely unstructured! Don't attempt
to integrate it anywhere directly!

/*
		//testing section
		
		_testPoint = new Point2D.Double(0,0);		
		_testCircle = new Circle2((float)_testPoint.x, 
								  (float)_testPoint.y, 
								  5.0f);
		
		_testGC = new GraphicsContext();
		
		_testGC.setFillColor(Color.white);
		_testGC.setForegroundColor(Color.black);
		_testGC.setBackgroundColor(Color.blue);
		_testGC.setFillStyle(1);		
		_test_rect = new Rectangle2D.Double(40,40,80,80);	*/
		
		/*
   		final JCheckBoxMenuItem buffer_item =
   		 new JCheckBoxMenuItem("Use hardware acceleration", false);
   		
   		
   		buffer_item.addActionListener(new ActionListener()
		{
   			public void actionPerformed(ActionEvent e)
   			{
   				m_bUseHardwareBuffer = buffer_item.isSelected();
   				
   				if(m_bUseHardwareBuffer)
   				{
   					// release 'normal' buffer
   					m_Renderer.dispose();
   					m_backBuffer.flush();
   					m_backBuffer = null; 
   					
   					// and create the hardware buffer
   					   					
   					m_hardwareBackBuffer = createVolatileImage(
							JSimpleDisplayPanel.this.getWidth(),
							JSimpleDisplayPanel.this.getHeight());
   					  					
   					m_Renderer = m_hardwareBackBuffer.createGraphics();
   				}
   				else
   				{
   					// vice-versa
   					m_Renderer.dispose();
   					m_hardwareBackBuffer.flush();
   					m_hardwareBackBuffer = null;
   					
   					m_backBuffer = (BufferedImage) createImage(
							JSimpleDisplayPanel.this.getWidth(),
							JSimpleDisplayPanel.this.getHeight());  					
   					
   					m_Renderer = m_backBuffer.createGraphics();
   				}
   				  				
   				repaint();
   			}
		});
   		
   		*/		

From tiny color chooser:

private BufferedImage m_triangleImage; // color triangle image
private float m_fTriangleVertices[]; // triangle vertex coordinates

//int change = NOTHING_CHANGED;
// initial color

// init 16 static colors for the swatches
		Color colors[] = 
		{
			Color.RED,	
			Color.PINK,
			Color.ORANGE,	
			Color.YELLOW,
			
			Color.MAGENTA,
			Color.GREEN,
			Color.CYAN,
			Color.BLUE,
						
			new Color(255,128,128), //Color.RED.brighter(),
			new Color(255,255,128), //Color.YELLOW.brighter(),
			new Color(128,255,128), //Color.GREEN.brighter(),
			new Color(128,128,255), //Color.BLUE.brighter(),
			
			Color.WHITE,
			Color.LIGHT_GRAY,
			Color.GRAY,
			Color.BLACK,
		};

/*
		// # of swatches is 4; thus 3 spaces between them 	
		int swatch_size = (m_iWidth - 2 * insets - 3 * spacing) / 4;	
		int x = insets; int y = insets;
		
		for(int i = 0; i < 4; i++)
		{
			for(int j = 0; j < 4; j++)
			{
				g.setColor(colors[i*4 + j]);
				g.fillRect(x,y, swatch_size, swatch_size);
				
				g.setColor(Color.black);
				g.drawRect(x,y, swatch_size, swatch_size);
				
				x += (swatch_size + spacing);
			}
			x = insets; // return back
			y+= (swatch_size + spacing);
		}*/

/*
int color =  Color.HSBtoRGB(m_fHue, 
							m_fSaturation, 
							m_fBrightness);*/
/*
// H/S/B update flags	
private static final int NOTHING_CHANGED   	= 0x00;
private static final int HUE_CHANGED 		= 0x01;
private static final int SAT_CHANGED 		= 0x02;
private static final int BRI_CHANGED 		= 0x04;*/

m_fTriangleVertices = new float[6]; // triangle vertex coords
		
		// calculate triangle vertices
		float tri_radius = m_fInnerRingRadius - 5;
		
		//tri_radius = 30;
		// vertex winding is as follows:	
		// V1 
		// |  \
		// |   V2		 
		// |  /
		// V3 
			
		m_fTriangleVertices[0] = 
			tri_radius * (float)Math.cos(4*PI/3)
									     + m_Center.x;
		
		m_fTriangleVertices[1] = 
			tri_radius * (float)Math.sin(4*PI/3)
									     + m_Center.y;
		
		m_fTriangleVertices[2] = tri_radius + m_Center.x;
		m_fTriangleVertices[3] = 0 + m_Center.y;
		
		m_fTriangleVertices[4] = 
			tri_radius * (float)Math.cos(2*PI/3)
									     + m_Center.x;
		
		m_fTriangleVertices[5] = 
			tri_radius * (float)Math.sin(2*PI/3)
									     + m_Center.y;
		
		// initialize image components
		
		m_triangleImage = 
			new BufferedImage(m_iWidth, m_iHeight,
					  BufferedImage.TYPE_INT_ARGB);

//temporary
/*
color = Color.HSBtoRGB(m_fHue, 
					   m_fSaturation, 
					   m_fBrightness);*/

// cursor in ring -> select hue and update
/* +/-1 constants are necessary to exclude the black
 * bounding circles from the test - otherwise hues
 * might 'jump' to 0.0(red) in certain situations
 * 
 */

/*
if(pointInRing(mouse_position, 
			   m_fInnerRingRadius + 1, 
			   m_fOuterRingRadius - 1))
{
	// get selected color 
	if(mouse_left_or_down)
	 m_fHue -= h_delta;
	
	if(mouse_right_or_up)
	 m_fHue += h_delta;
	
	
	
	//color = m_ringImage.getRGB(mouse_position.x, 
	//					   mouse_position.y);
	
	//m_hMarkerPosition.setLocation(mouse_position);
	change = HUE_CHANGED;
}*/

/*
// cursor is in saturation slider -> adjust S and update
if(pointInArc(mouse_position, 
			  m_fInnerSliderRadius + 1,
			  m_fOuterSliderRadius - 1,
			  -1, 1))
{
	
	//get selected color 
	color = m_sliderImage.getRGB(mouse_position.x, 
								 mouse_position.y);
	
	m_sMarkerPosition.setLocation(mouse_position);
	change = SAT_CHANGED;
				
}

//cursor is in brightness slider -> adjust B and update
if(pointInArc(mouse_position, 
			  m_fInnerSliderRadius + 1,
			  m_fOuterSliderRadius - 1,
			  1, -1))
{
	
	//get selected color 
	color = m_sliderImage.getRGB(mouse_position.x, 
								 mouse_position.y);
	
	m_bMarkerPosition.setLocation(mouse_position);
	change = BRI_CHANGED;
	
}*/


/* Draw the markers. the extra math code
 * ensures that the marker circles stay centered
 * in the rings and don't jump around wildly
 *  
 */

/*
// compute direction vector from center to the marker position
direction.setLocation
				   (m_hMarkerPosition.x - m_Center.x,
					m_hMarkerPosition.y - m_Center.y);

// normalize
length = Math.sqrt(direction.x * direction.x 
				   + direction.y * direction.y);

direction.x /= length;
direction.y /= length;


		
marker_center.setLocation
 					 (m_Center.x + direction.x * mid_radius, 
		 			  m_Center.y + direction.y * mid_radius);*/



/*		
//compute direction vector from center to the marker position
direction.setLocation
				   (m_sMarkerPosition.x - m_Center.x,
					m_sMarkerPosition.y - m_Center.y);

// normalize
length = Math.sqrt(direction.x * direction.x 
				   + direction.y * direction.y);

direction.x /= length;
direction.y /= length;

mid_radius = 0.5f * (m_fInnerSliderRadius + m_fOuterSliderRadius);
		
marker_center.setLocation
 					 (m_Center.x + direction.x * mid_radius, 
		 			  m_Center.y + direction.y * mid_radius);

g2d.drawOval(Math.round(marker_center.x) - MARKER_RADIUS,
		     Math.round(marker_center.y) - MARKER_RADIUS,
		     2 * MARKER_RADIUS, 2 * MARKER_RADIUS);*/

// brightness marker

/*
//compute direction vector from center to the marker position
direction.setLocation
				   (m_bMarkerPosition.x - m_Center.x,
					m_bMarkerPosition.y - m_Center.y);

// normalize
length = Math.sqrt(direction.x * direction.x 
				   + direction.y * direction.y);

direction.x /= length;
direction.y /= length;

//mid_radius = 0.5f * (m_fInnerSliderRadius + m_fOuterSliderRadius);
		
marker_center.setLocation
 					 (m_Center.x + direction.x * mid_radius, 
		 			  m_Center.y + direction.y * mid_radius);

g2d.drawOval(Math.round(marker_center.x) - MARKER_RADIUS,
		     Math.round(marker_center.y) - MARKER_RADIUS,
		     2 * MARKER_RADIUS, 2 * MARKER_RADIUS);*/

/*
float hsb[] = new float[3]; // hsb color components

hsb[0] = m_fHue;
hsb[1] = m_fSaturation;
hsb[2] = m_fBrightness;

//decode and convert to HSB space
int r = (color_code >> 16)& 0xFF;
int g = (color_code >> 8) & 0xFF;
int b = (color_code >> 0) & 0xFF;

Color.RGBtoHSB(r,g,b,hsb);*/

/* due to some roundoff errors
 * (and probably bugs in implementation as well)
 * the saturation and brightness values never become
 * strictly 0.0 or 1.0, so we need to persuade them
 * a little...
 */

/*
if(hsb[1] < 0.015f)
 hsb[1] = 0.0f;

if(hsb[1] > 0.99f)
 hsb[1] = 1.0f;

if(hsb[2] < 0.015f)
	 hsb[2] = 0.0f;
	
if(hsb[2] > 0.99f)
 hsb[2] = 1.0f;

// now update the global HSB values accordingly
switch(change_code)
{
	case NOTHING_CHANGED: // don't touch anything
	break;
	
	case HUE_CHANGED:
	 m_fHue = hsb[0];
	break;
	
	case SAT_CHANGED:
	 m_fSaturation = hsb[1];
	break;
	
	case BRI_CHANGED:
	 m_fBrightness = hsb[2];
	break;
	
}*/
		
//bri = m_fBaseBrightness - 
//(y - m_colorRectangle.y) * b_delta;		
//sat = m_fBaseSaturation - 
//	  (x - m_colorRectangle.x) * s_delta;


/*
int color = m_squareImage.getRGB(m_colorMarkerPosition.x, 
								 m_colorMarkerPosition.y);
				
//decode and convert to HSB space
int r = (color >> 16)& 0xFF;
int g = (color >> 8) & 0xFF;
int b = (color >> 0) & 0xFF;

Color.RGBtoHSB(r,g,b,hsb);

// see comments in mouseReleased()
if(hsb[1] < 0.015f)
 hsb[1] = 0.0f;

if(hsb[1] > 0.99f)
 hsb[1] = 1.0f;

if(hsb[2] < 0.08f)
	 hsb[2] = 0.0f;
	
if(hsb[2] > 0.99f)
 hsb[2] = 1.0f;*/

/* Special case handling for sliding the marker inside the
 * color triangle. 
 */
/*	
if(pointInTriangle(mouse_position, m_fTriangleVertices))
{	
	// use delta movement
	//if(mouse_left) m_colorMarkerPosition.x--;
	//if(mouse_right) m_colorMarkerPosition.x++;
	//if(mouse_up) m_colorMarkerPosition.y++;
	//if(mouse_down) m_colorMarkerPosition.y--;
			
	
	m_colorMarkerPosition.setLocation(mouse_position);								
	//int color = m_triangleImage.getRGB(mouse_position.x, 
	//								   mouse_position.y);
	
	int color = m_triangleImage.getRGB(m_colorMarkerPosition.x, 
									   m_colorMarkerPosition.y);
	
	
	float hsb[] = new float[3];
	
	//decode and convert to HSB space
	int r = (color >> 16)& 0xFF;
	int g = (color >> 8) & 0xFF;
	int b = (color >> 0) & 0xFF;
	
	Color.RGBtoHSB(r,g,b,hsb);
	
	// see comments in mouseReleased()
	if(hsb[1] < 0.015f)
	 hsb[1] = 0.0f;
	
	if(hsb[1] > 0.99f)
	 hsb[1] = 1.0f;
	
	if(hsb[2] < 0.015f)
		 hsb[2] = 0.0f;
		
	if(hsb[2] > 0.99f)
	 hsb[2] = 1.0f;
	
	m_fHue 		  = hsb[0];
	m_fSaturation = hsb[1];
	m_fBrightness = hsb[2];
	
}*/


/**
	 * This code has been converted from pseudocode at
	 * <a href=
	 * "http://www-users.mat.uni.torun.pl/~wrona/3d_tutor/tri_fillers.html">
	 * 
	 * Look there for explanations etc.
	 * 
	 * 
	 * @param image target image object
	 * @param x1 x-coord of the first vertex
	 * @param y1 y-coord of the first vertex
	 * @param c1 color of the first vertex
	 * 
	 * @param x2 x-coord of the second vertex
	 * @param y2 y-coord of the second vertex
	 * @param c2 color of the second vertex
	 * 
	 * @param x3
	 * @param y3
	 * @param c3
	 */
		
	private void fillGouraudTriangle(BufferedImage image,
									 float x1, float y1,
									 float x2, float y2,
									 float x3, float y3,
									 int c1, int c2, int c3)
	{
		class Vertex
		{
			float	x	= 0;
			float	y	= 0;
			float	r	= 0, g = 0, b = 0;
			Vertex()
			{}
			Vertex(float xx, float yy, float rr, float gg, float bb)
			{
				x = xx;
				y = yy;
				r = rr;
				g = gg;
				b = bb;
			}
			Vertex(Vertex source)
			{
				this(source.x, source.y, source.r, source.g, source.b);
			}
			
			Vertex(float xx, float yy, int color)
			{
				x = xx; y = yy; 
				
				// decode colors from 32-bit int and normalize them
				r = ((color >> 16)& 0xFF) / 255.0f;
				g = ((color >> 8) & 0xFF) / 255.0f;
				b = ((color >> 0) & 0xFF) / 255.0f;
				
			}
			void setTo(Vertex source)
			{
				x = source.x;
				y = source.y;
				r = source.r;
				g = source.g;
				b = source.b;
			}
			int getColor()
			{
				/* r,g,b components are converted from 
				 * [0,1] to [0,255] */
				int color =   ((         255  & 0xFF) << 24) | 
							  (( (int)(r*255) & 0xFF) << 16) | 
							  (( (int)(g*255) & 0xFF) << 8) | 
							  (( (int)(b*255) & 0xFF) << 0);
				return color;
			}
		};
				
		Vertex A = new Vertex(x1, y1, c1);
		Vertex B = new Vertex(x2, y2, c2);
		Vertex C = new Vertex(x3, y3, c3);
		
		
		// deltas used for interpolation of x-coordinates
		float dx1, dx2, dx3;
		// deltas used for interpolation of r,g,b color components
		float dr, dg, db;
		float dr1, dr2, dr3;
		float dg1, dg2, dg3;
		float db1, db2, db3;
		// compute deltas for x and colors
		if(B.y - A.y > 0)
		{
			dx1 = (B.x - A.x) / (B.y - A.y);
			dr1 = (B.r - A.r) / (B.y - A.y);
			dg1 = (B.g - A.g) / (B.y - A.y);
			db1 = (B.b - A.b) / (B.y - A.y);
		} else dx1 = dr1 = dg1 = db1 = 0;
		
		if(C.y - A.y > 0)
		{
			dx2 = (C.x - A.x) / (C.y - A.y);
			dr2 = (C.r - A.r) / (C.y - A.y);
			dg2 = (C.g - A.g) / (C.y - A.y);
			db2 = (C.b - A.b) / (C.y - A.y);
		} else dx2 = dr2 = dg2 = db2 = 0;
		
		if(C.y - B.y > 0)
		{
			dx3 = (C.x - B.x) / (C.y - B.y);
			dr3 = (C.r - B.r) / (C.y - B.y);
			dg3 = (C.g - B.g) / (C.y - B.y);
			db3 = (C.b - B.b) / (C.y - B.y);
		} else dx3 = dr3 = dg3 = db3 = 0;
		
		// now scan-convert and fill the triangle
		// S and E are starting and ending points of a segment
		//S=E=A;
		Vertex S = new Vertex(A);
		Vertex E = new Vertex(A);
		Vertex P = new Vertex(); // intrmediate point
		
		if(dx1 > dx2)
		{
			for(; S.y <= B.y; S.y++, E.y++)
			{
				if(E.x - S.x > 0)
				{
					dr = (E.r - S.r) / (E.x - S.x);
					dg = (E.g - S.g) / (E.x - S.x);
					db = (E.b - S.b) / (E.x - S.x);
				} else dr = dg = db = 0;
				// P = S
				P.setTo(S);
				for(; P.x < E.x; P.x++)
				{
					//putpixel(P);
					image.setRGB(Math.round(P.x), Math.round(P.y), 
								 P.getColor());
					P.r += dr;
					P.g += dg;
					P.b += db;
				}
				S.x += dx2;
				S.r += dr2;
				S.g += dg2;
				S.b += db2;
				E.x += dx1;
				E.r += dr1;
				E.g += dg1;
				E.b += db1;
			}
			//E = B;
			E.setTo(B);
			for(; S.y <= C.y; S.y++, E.y++)
			{
				if(E.x - S.x > 0)
				{
					dr = (E.r - S.r) / (E.x - S.x);
					dg = (E.g - S.g) / (E.x - S.x);
					db = (E.b - S.b) / (E.x - S.x);
				} else dr = dg = db = 0;
				//P = S;
				P.setTo(S);
				for(; P.x < E.x; P.x++)
				{
					//putpixel(P);
					image.setRGB(Math.round(P.x), Math.round(P.y), 
							 	 P.getColor());
					
					P.r += dr;
					P.g += dg;
					P.b += db;
				}
				S.x += dx2;
				S.r += dr2;
				S.g += dg2;
				S.b += db2;
				E.x += dx3;
				E.r += dr3;
				E.g += dg3;
				E.b += db3;
			}
		} else
		{
			for(; S.y <= B.y; S.y++, E.y++)
			{
				if(E.x - S.x > 0)
				{
					dr = (E.r - S.r) / (E.x - S.x);
					dg = (E.g - S.g) / (E.x - S.x);
					db = (E.b - S.b) / (E.x - S.x);
				} else dr = dg = db = 0;
				//P = S;
				P.setTo(S);
				for(; P.x < E.x; P.x++)
				{
					//putpixel(P);
					//image.setRGB((int)P.x, (int)P.y, P.getColor());
					image.setRGB(Math.round(P.x), Math.round(P.y), 
							 	 P.getColor());
					
					P.r += dr;
					P.g += dg;
					P.b += db;
				}
				S.x += dx1;
				S.r += dr1;
				S.g += dg1;
				S.b += db1;
				E.x += dx2;
				E.r += dr2;
				E.g += dg2;
				E.b += db2;
			}
			//S = B;
			S.setTo(B);
			for(; S.y <= C.y; S.y++, E.y++)
			{
				if(E.x - S.x > 0)
				{
					dr = (E.r - S.r) / (E.x - S.x);
					dg = (E.g - S.g) / (E.x - S.x);
					db = (E.b - S.b) / (E.x - S.x);
				} else dr = dg = db = 0;
				//P = S;
				P.setTo(S);
				for(; P.x < E.x; P.x++)
				{
					//putpixel(P);
					//image.setRGB((int)P.x, (int)P.y, P.getColor());
					
					image.setRGB(Math.round(P.x), Math.round(P.y), 
							 	 P.getColor());
					
					P.r += dr;
					P.g += dg;
					P.b += db;
				}
				S.x += dx3;
				S.r += dr3;
				S.g += dg3;
				S.b += db3;
				E.x += dx2;
				E.r += dr2;
				E.g += dg2;
				E.b += db2;
			}
		}
	}
	
	/* Snap (and project) a point onto the line 
	 * segment between (x1,y1) and (x2, y2);
	 */
	
	private void snapPointToLine(Point p, 
								 float x1, float y1,
								 float x2, float y2)
	{
		/* first, we need distance between point and line 
		 * which is defined as |x-P(x)|, P(x) being the
		 * projection of x on the line segment between(x1,y1)
		 * and (x2,y2)
		 */
	 				
		Point2D.Float dir = new Point2D.Float(x2 - x1, y2 - y1);
		Point2D.Float projection = new Point2D.Float();
				
		// project point onto the line
		float numerator   =   (p.x - x1) * dir.x + (p.y - y1) * dir.y;
		float denominator = dir.x * dir.x + dir.y * dir.y;
		float scale = numerator / denominator;
				
		projection.x = dir.x * scale + x1;
		projection.y = dir.y * scale + y1;
		
		double distance 
		 = Math.sqrt((p.x - projection.x)*(p.x - projection.x) +
		 			 (p.y - projection.y)*(p.y - projection.y));
		
		if(distance < 3.0f)
		{
			p.x = Math.round(projection.x);
			p.y = Math.round(projection.y);
		}
	}
	
	
	/**
	 * Tests whether a point lies with the specified triangle.
	 * This method expectes cclockwise winding of the vertices, 
	 * otherwise results will be inverted.
	 * 
	 * @param p point to be tested
	 * @param tri_vts triangle vertices as interleaved x,y coords
	 * @return true if point is inside
	 */
	private boolean pointInTriangle(Point p,
									float tri_vts[])
	{
		boolean in1 = (det(p, 
					   tri_vts[0], 
					   tri_vts[1], 
					   tri_vts[2],
					   tri_vts[3]) > 0);
		
		if( in1 == false) return false;
		
		boolean in2 = (det(p, 
					   tri_vts[2], 
					   tri_vts[3], 
					   tri_vts[4],
					   tri_vts[5]) > 0);
		
		if(in2 == false) return false;
		
		boolean in3 = (det(p, 
					   tri_vts[4], 
					   tri_vts[5], 
					   tri_vts[0],
					   tri_vts[1]) > 0);
		
		return (in1 & in2 & in3);
	}
	
	
	private float det(Point p,
					  float x1, float y1,
					  float x2, float y2)
	{
		float term1 = (x1 - p.x) * (y2 - p.y);
		float term2 = (x2 - p.x) * (y1 - p.y);
		
		return (term1 - term2);
	}
	
	private void drawColorTriangle()
	{
		//set background color
		Graphics2D g = (Graphics2D)m_triangleImage.getGraphics();
				
		// black color with alpha value of 0
		g.setBackground(new Color(0,0,0,0));		
		g.clearRect(0,0,m_triangleImage.getWidth(), 
						m_triangleImage.getHeight());
		
		fillGouraudTriangle(m_triangleImage,
							m_fTriangleVertices[0], m_fTriangleVertices[1], 	
							m_fTriangleVertices[2], m_fTriangleVertices[3],
							m_fTriangleVertices[4], m_fTriangleVertices[5],
							Color.HSBtoRGB(m_fBaseHue, 
										   m_fBaseSaturation, 
										   m_fBaseBrightness),
							Color.HSBtoRGB(m_fBaseHue, 0.0f, 1.0f),
							Color.HSBtoRGB(m_fBaseHue, 0.0f, 0.0f)
							);
		
		// draw antialiased edges
		g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
						   RenderingHints.VALUE_ANTIALIAS_ON);
		
		BasicStroke stroke = new BasicStroke(1.0f, 
											 BasicStroke.CAP_BUTT,
											 BasicStroke.JOIN_ROUND);
		g.setStroke(stroke);				
		g.setColor(Color.lightGray);
		
		g.drawLine(Math.round(m_fTriangleVertices[0]), 
				   Math.round(m_fTriangleVertices[1]),
				   Math.round(m_fTriangleVertices[2]), 
				   Math.round(m_fTriangleVertices[3]));
		
		g.drawLine(Math.round(m_fTriangleVertices[2]), 
				   Math.round(m_fTriangleVertices[3]),
				   Math.round(m_fTriangleVertices[4]), 
				   Math.round(m_fTriangleVertices[5]));
		
		g.drawLine(Math.round(m_fTriangleVertices[4]), 
				   Math.round(m_fTriangleVertices[5]),
				   Math.round(m_fTriangleVertices[0]), 
				   Math.round(m_fTriangleVertices[1]));
		
		g.dispose(); // done
	}
	
	
	
			// FUCK!
			//RescaleOp brighten = new RescaleOp(1.0f, 0.0f, null);
			//brighten.filter(img, m_HSBicon);
			
			/*
			// try to filter the icon manually!
			WritableRaster raster = m_HSBicon.getRaster();
			float rgb[] = new float[4];
			
			float scale = 200.0f;
			
			for(int i = 0; i < raster.getHeight(); i++)
			{
				for(int j = 0; j < raster.getWidth(); j++)
				{
					raster.getPixel(i,j, rgb);
					
					if((rgb[0] == rgb[1]) & (rgb[1] == rgb[2]))
					{
						rgb[0] = scale;
						rgb[1] = scale;
						rgb[2] = scale;
					}
					
					raster.setPixel(i,j, rgb);
				}
			}*/
			
			// END test
			
			/*
		m_mainImage = 
		 new BufferedImage(m_iWidth, m_iHeight,
		 				   BufferedImage.TYPE_INT_ARGB);
		//set common background
		Graphics2D g = (Graphics2D)m_mainImage.getGraphics();
		g.setBackground(BACKGROUND_COLOR);
		g.clearRect(0,0, m_iWidth, m_iHeight);
		g.dispose();*/
		
		/*
		// cursor is in color triangle -> adjust B/S
		if(pointInTriangle(mouse_position, m_fTriangleVertices))
		{			
			m_iChangeMode = COLOR_MODE;
			m_colorMarkerPosition.setLocation(mouse_position);
		}*/
		
		
		// JUNK

/*
start = screenToWorldX(BORDER_WIDTH + 
		((m_iArrowType == NO_ARROWS)?0:(ARROW_WIDTH+3)));
			
end   = screenToWorldX(m_iDisplayWidth - BORDER_WIDTH - 
		((m_iArrowType == NO_ARROWS)?0:(ARROW_WIDTH+3))); */

/* The below manipulations with Math.ceil and Math.floor
 * are necessary to produce tick positions that are integer
 * multiples of the pitch values. 
 * (i.e if the start is -23 and end is +18, and the 
 * coarse pitch is 5, the coarse ticks should
 * run from -20 to +15)
 */
/*
start = Math.ceil(start / m_dCoarsePitchX) * m_dCoarsePitchX;
end   = Math.floor(end / m_dCoarsePitchX) * m_dCoarsePitchX; */

/*
int distance = worldToScreenX(m_dCoarsePitchX) -
			   worldToScreenX(0);

System.out.println("tick distance in pixels:"+distance);

// figure out when to update the pitch values
//when zoomin in		
if(distance > 40)
{
	//decrease pitch values
	m_dCoarsePitchX /= 10.0; //SUBDIVISION_FACTOR;
	m_dFinePitchX = m_dCoarsePitchX / m_iTicksPerUnit;			
}

if(distance > 40)
{
	m_dCoarsePitchY /= 10.0; //SUBDIVISION_FACTOR;
	m_dFinePitchY= m_dCoarsePitchY / m_iTicksPerUnit;
}
		
// when zooming out
if(distance < 20)
{
	//increase pitch values
	m_dCoarsePitchX *= 10.0; //SUBDIVISION_FACTOR;
	m_dFinePitchX = m_dCoarsePitchX / m_iTicksPerUnit;			
}

if(distance < 20)
{
	m_dCoarsePitchY *= 10.0; //SUBDIVISION_FACTOR;
	m_dFinePitchY = m_dCoarsePitchY / m_iTicksPerUnit;
} 
*/

From JGenericGraphEditor

/*
//testing event handling
Point position = event.getPoint();

Point2 wp = new Point2();		
m_coordSystem.screenToWorld(position, wp, true);			
VisualVertex v = m_Scene.getHotVertex(wp);

if(v != null)
 v._drawAchor = true;	*/


/*
JGraphObject obj = (JGraphObject)m_Scene.getAnchoredObject(wp);

if(obj != null)
	obj.getVertex()._drawAchor = true;*/

/*
// test selection / proximity sensing 

//testing event handling
Point position = event.getPoint();

Point2 wp = new Point2();		
m_coordSystem.screenToWorld(position, wp, true);

VisualVertex vx = m_Scene.getVertex(wp);

if(vx != null)
{
	_selected_vx = vx;
	//System.out.println("Vertex hit!");	
	vx.clicked();
}*/
/* debugging output is disabled now */
/*
AffineTransform tx = g.getTransform();
{
	g.setTransform(new AffineTransform());
	
	String text;
	switch(m_iHitFlag)
	{
		case HIT_EDGE:
			text = "HIT_EDGE";
		break;	
			
		case HIT_VERTEX:
			text = "HIT_VERTEX";
		break;
			
		case HIT_PROXY_ZONE:
			text = "HIT_PROXY";
		break;
		
		case HIT_SELECTION:
			text = "HIT_SELECTION";
		break;
		
		case HIT_NOTHING:
			text = "HIT_NOTHING";
		break;
		
		default:
		  text = "NIX";
		break;
	}
	
	g.drawString(text,20,100);
	
}
g.setTransform(tx); */

// create test graph for event handler testing
		/*
		
		VisualVertex v;
		v = new VisualVertex
		 	("X", Color.white, new Point2(-50,-50),15);
		
		m_Scene.addVertex(v);
		m_Scene.generateEdges(v);
		
		v = new VisualVertex
		 ("X", Color.white, new Point2(-50,50),15);
		
		m_Scene.addVertex(v);
		m_Scene.generateEdges(v);
		
		v = new VisualVertex
		 ("X", Color.white, new Point2(50,50),15);
		
		m_Scene.addVertex(v);
		m_Scene.generateEdges(v);
		
		v = new VisualVertex
		 ("X", Color.white, new Point2(50,-50),15);
		
		m_Scene.addVertex(v);
		m_Scene.generateEdges(v);
		
		//m_Scene.generateEdges(v);*/
		
		/*
				// deselect previous vertices / edges
				if(m_activeVertex !=null)
				{
					m_activeVertex.deselect();
					m_activeVertex = null;
				}
				
				if(m_activeEdge != null)
				{
					m_activeEdge.deselect();
					m_activeEdge = null;
				}
					
				if(m_proxyVertex != null)
				{
					m_proxyVertex.deselect();
					m_proxyVertex = null;
				}*/
				
				/*
					if(m_activeVertex != null)
					{
						m_activeVertex.deselect();
						m_activeVertex = null;
					}
					
					if(m_proxyVertex != null)
					{
					  m_proxyVertex.deselect();
					  m_proxyVertex = null;
					}
					
					if(m_activeEdge != null)
					{
						m_activeEdge.deselect();
						m_activeEdge = null;
					}*/
					
					 /*
					 if(m_activeVertex != null)
					 {
					 	m_activeVertex.deselect();
					 	m_activeVertex = null;
					 }
					 					 
					 // deselect previous edge
					 if(m_activeEdge != null)
					 {
					 	m_activeEdge.deselect();
					 	m_activeEdge = null;
					 }*/
					 
					 if(m_activeVertex != null)
						{
							m_activeVertex.deselect();
							m_activeVertex = null;
						}
						
						if(m_activeEdge != null)
						{
							m_activeEdge.deselect();
							m_activeEdge = null;
						}*/
						
						
						/*
					if(m_activeVertex != null)
					{
					  m_activeVertex.deselect();
					  m_activeVertex = null;
					}
					
					if(m_proxyVertex != null)
					 m_proxyVertex = null;
					
					if(m_activeEdge != null)
					{
					  m_activeEdge.deselect();
					  m_activeEdge = null;
					}*/
					
					/ JUNK
/*
//testing event handling
Point position = event.getPoint();

Point2 wp = new Point2();		
m_coordSystem.screenToWorld(position, wp, true);			
VisualVertex v = m_Scene.getHotVertex(wp);

if(v != null)
 v._drawAchor = true;	*/


/*
JGraphObject obj = (JGraphObject)m_Scene.getAnchoredObject(wp);

if(obj != null)
	obj.getVertex()._drawAchor = true;*/

/*
// test selection / proximity sensing 

//testing event handling
Point position = event.getPoint();

Point2 wp = new Point2();		
m_coordSystem.screenToWorld(position, wp, true);

VisualVertex vx = m_Scene.getVertex(wp);

if(vx != null)
{
	_selected_vx = vx;
	//System.out.println("Vertex hit!");	
	vx.clicked();
}*/
/* debugging output is disabled now */
/*
AffineTransform tx = g.getTransform();
{
	g.setTransform(new AffineTransform());
	
	String text;
	switch(m_iHitFlag)
	{
		case HIT_EDGE:
			text = "HIT_EDGE";
		break;	
			
		case HIT_VERTEX:
			text = "HIT_VERTEX";
		break;
			
		case HIT_PROXY_ZONE:
			text = "HIT_PROXY";
		break;
		
		case HIT_SELECTION:
			text = "HIT_SELECTION";
		break;
		
		case HIT_NOTHING:
			text = "HIT_NOTHING";
		break;
		
		default:
		  text = "NIX";
		break;
	}
	
	g.drawString(text,20,100);
	
}
g.setTransform(tx); */

From EditorActionEvent

/**
	 * Default constructor. Such an event should generally not
	 * be used on its own. One conceiveable exception would
	 * be an "empty" event that caries no other information
	 * than some action has occured inside an editor. 
	 * 
	 */
	 
	 
	 /**
	 * 
	 * 
	 */
	//public void vertexAdded(VisualVertex vertex);
	
	/**
	 * 
	 * @param vertex
	 */
	//public void vertexMoved(VisualVertex vertex);
	
	/**
	 * 
	 * @param vertex
	 */
	//public void vertexRemoved(VisualVertex vertex);
	
	/**
	 * 
	 * @param vertex
	 * @param property
	 */
	//public void vertexPropsChanged(VisualVertex vertex, int property);
	
	/**
	 * 
	 * @param edge
	 */
	//public void edgeAdded(VisualEdge edge);
	
	/**
	 * 
	 * @param edge
	 */
	//public void edgeMoved(VisualEdge edge);
	
	/**
	 * 
	 * @param edge
	 */
	//public void edgeRemoved(VisualEdge edge);
	
	/**
	 * 
	 * @param edge
	 * @param property
	 */
	//public void edgePropsChanged(VisualEdge edge, int property);
	
	/**
	 * 
	 * @param edge
	 */
	//public void edgeModified(VisualEdge edge);
	
	/**
	 * 
	 * @param selection
	 */
	//public void vertexSelectionMoved(Vector selection);
	
	/**
	 * 
	 * @param selection
	 */
	//public void vertexSelectionRemoved(Vector selection);
	
	/**
	 * 
	 * @param selection
	 */
	//public void vertexSelectionModified(Vector selection);
	
	/**
	 * 
	 * @param selection
	 */
	//public void edgeSelectionMoved(Vector selection);
	
	/**
	 * 
	 * @param selection
	 */
	//public void edgeSelectionRemoved(Vector selection);
	
	/**
	 * 
	 * @param selection
	 */
	//public void edgeSelectionModified(Vector selection);					


/*
	public void addVertex(VisualVertex vx)
	{
		
	}
	
	public void deleteVertex(VisualVertex vx)
	{
		
	}
	
	public void moveVertex(VisualVertex vx, Point2 position)
	{
		vx.moveTo(position);
		
	}
	
	public void changeVertexAttributes(VisualVertex vx,
									   int attribute,
									   Color color,
									   String name,
									   int radius)
	{
		switch(attribute)
		{
			case VERTEX_COLOR_CHANGED:
			break;
			
			case VERTEX_NAME_CHANGED:
			break;
			
			case VERTEX_RADIUS_CHANGED:
			break;
			
			default:
			break;
		}		
	}*/
	
	/*
	protected void fireVertexAdded(VisualVertex vertex)
	{
		Enumeration e = m_graphListeners.elements();
		GraphListener listener;
		
		while(e.hasMoreElements())
		{
			listener = (GraphListener)e.nextElement();	
			listener.vertexAdded(vertex);
		}	
	}*/		
	
	/*
					m_vertexUndo.setType(VERTEX_REMOVED);
					putUndoAction(m_vertexUndo);*/
					
					/*
					GraphEditorEvent e =
					 new GraphEditorEvent(this, m_activeVertex,
					 					  VERTEX_REMOVED);
					fireEditorActionEvent(e);*/
					
					
					/**
	 * "Undo factory" method
	 *  
	 */
	/*
	protected void storeUndo(JGenericGraphScene  scene,
							 JGenericGraphEditor editor,		 
							 VisualVertex vertex,
							 VisualEdge edge,
							 Vector selection,
							 int undoType)
	{
		JAbstractUndoAction undoAction = null;
		
		switch(undoType)
		{
			case VERTEX_ADDED:
			case VERTEX_REMOVED:
			case VERTEX_MOVED:
			case VERTEX_COLOR_CHANGED:
			case VERTEX_NAME_CHANGED:
			case VERTEX_RADIUS_CHANGED:
			
			undoAction = new JVertexUndo(scene,editor,
										 vertex,null, undoType);
				
			break;
			
			//TODO: Edge and selection undos
		}
		
		putUndoAction(undoAction);
		
	}*/
	
	/* Since we don't know yet which action
					 * will be performed, other than the fact
					 * that we're operating on a vertex,
					 * the type of undo is set to NO_ACTION, 
					 * and will be modified later in the 
					 * other event handlers after a specific
					 * action has been performed. Essentially
					 * this steps just remembers the vertex
					 * data prior to modification. 
					 */
					
					
					m_vertexUndo = new JVertexUndo
					(m_Scene, this, m_activeVertex, null, NO_ACTION);
					
					
					public void setType(int type)
	{
		super.setType(type);
		
		/* Special case handling. The adjacent edge list
		 * is only saved when a vertex is really remove,
		 * in order not to waste memory when it's not 
		 * necessary. 
		 */
		
		if(type == VERTEX_REMOVED)
		{					
			m_edgeList = new Vector();					
			LinkedList edges 
			= ((JGenericGraphScene)m_Scene).getAdjacentEdges(m_Vertex);
			
			// vertex has no adjacent edges 
			if(edges == null) return;
			
			Iterator it = edges.iterator();			
			VisualEdge ve;
			
			while(it.hasNext())
			{
				ve = (VisualEdge)it.next();
				m_edgeList.add(ve);
			}
		}
	}	
	
	/*
					GraphEditorEvent e =
					 new GraphEditorEvent(this,m_activeEdge,
					 				   	  EDGE_REMOVED);
					fireEditorActionEvent(e);*/	
					
						/*
				GraphEditorEvent e = 
					new GraphEditorEvent(this,
							m_selectionSet,
							VERTEX_SELECTION_REMOVED);
				fireEditorActionEvent(e);*/
				
					/*
						m_vertexUndo = 
						 new JVertexUndo(m_Scene, this,						 		
						 		new_vertex, null, VERTEX_ADDED);						
						putUndoAction(m_vertexUndo);*/
												
						/*
						gev =
						 new GraphEditorEvent(
					 		this, new_vertex, VERTEX_ADDED);
						
						fireEditorActionEvent(gev);*/
						
							/*
						gev = new GraphEditorEvent(
							  this, m_selectionSet,
							  VERTEX_SELECTION_CHANGED);
							
						fireEditorActionEvent(gev);*/
						
						//m_vertexUndo.setType(VERTEX_MOVED);
					//putUndoAction(m_vertexUndo);
					
						/*
						gev = new GraphEditorEvent
						(this, ve, EDGE_ADDED);
						
						fireEditorActionEvent(gev);*/
						
						/*
					gev = new GraphEditorEvent(
						  this, m_selectionSet,
						  VERTEX_SELECTION_CHANGED);					
					fireEditorActionEvent(gev);*/
					
					/*
			GraphEditorEvent e = new GraphEditorEvent
			(this, m_activeVertex, VERTEX_COLOR_CHANGED);
			
			fireEditorActionEvent(e);*/
			
				/*
			GraphEditorEvent e = new GraphEditorEvent
			(this, m_activeEdge, EDGE_COLOR_CHANGED);
			
			fireEditorActionEvent(e);*/
			
			
			/**
	 * This method acts as a "factory" - it generates and fires
	 * various events based on the event type parameter. Used
	 * internally by the graph editor, and also by undo actions.
	 * 
	 * 
	 * @param editor
	 * @param vertex
	 * @param edge
	 * @param selection
	 * @param eventType {@link GraphConstants}
	 * 
	 * @see GraphConstants for event types
	 *  
	 */
	/*
	public void fireGraphEditorEvent(JGenericGraphEditor editor,
							   		 VisualVertex vertex,
									 VisualEdge edge,
									 Vector selection,
									 int eventType)
	{
		GraphEditorEvent event = null;
		
		switch(eventType)
		{
			case VERTEX_ADDED:	
			case VERTEX_MOVED:	
			case VERTEX_REMOVED:
			case VERTEX_COLOR_CHANGED:
			case VERTEX_NAME_CHANGED:
			case VERTEX_RADIUS_CHANGED:
			
			event = new GraphEditorEvent(editor,vertex,eventType);
			
			case EDGE_ADDED:
			case EDGE_REMOVED:
			case EDGE_COLOR_CHANGED:
			case EDGE_WEIGHT_CHANGED:
			
			event = new GraphEditorEvent(editor,edge, eventType);
				
			break;
			
			case EDGE_MODIFIED:							
			break;
			
			// TODO: Selection events
		}
		
		// fire the new event
		fireEditorActionEvent(event);
	}*/
	
	//test section
			
			/*
			Image img = rot_icon.getImage();
			
			BufferedImage source = new BufferedImage(rot_icon.getIconWidth(),
													 rot_icon.getIconHeight(),	
													 BufferedImage.TYPE_INT_ARGB);
			Graphics g = source.getGraphics();
			g.drawImage(img, 0, 0, null);
			g.dispose();
			
			Raster rt = source.getAlphaRaster();
			
			SampleModel m = rt.getSampleModel();
			int numcomponents = m.getNumBands();
			
			int components[] = new int[numcomponents];
			System.out.println(numcomponents);
			
			
			for(int i = 0; i < rt.getHeight(); i++)
			{
				for(int j = 0; j < rt.getWidth(); j++)
				{		
					rt.getPixel(j,i,components);
					
					m_Hub.getTextDump().print((components[0] == 0?"0":"1"));
				}
				m_Hub.getTextDump().println("");
			}*/
			
			
			// END
			
				/*
					// x axis
					source_distance = Math.abs(corner.x - center.x);
					target_distance = Math.abs(target.x - center.x);
					
					xscale = target_distance / source_distance;
					
					// y axis
					
					source_distance = Math.abs(corner.y - center.y);
					target_distance = Math.abs(target.y - center.y);
					
					yscale = target_distance / source_distance;
					
					scale = Math.max(xscale, yscale);*/
			
			
			else
		{
			// scale relative to a specific location
			switch(m_iTransformFlag)
			{
				case NW_SCALE:
				break;
				
				case N_SCALE:
				break;
				
				case NE_SCALE:
				break;
				
				case E_SCALE:
				break;
				
				case SE_SCALE:
				break;
				
				case S_SCALE:
				break;
				
				case SW_SCALE:
				break;
				
				case W_SCALE:
				break;
			}
		}
		
		/*
		
		//if( (limiter.contains(target) == true)  && 
		//	(limiter.contains(source) == false))
		{
				
			//m_Hub.getTextDump().println("Mouse in limiter");
			
			// test which direction the mouse came from
			int outcode = limiter.outcode(source);
			
			boolean left = false, right = false;
			boolean top = false, bottom = false;
					
			if((outcode & Rectangle2D.OUT_LEFT) == Rectangle2D.OUT_LEFT)
			{
				left = true;
				m_Hub.getTextDump().println("From Left");			
			}
			
			if((outcode & Rectangle2D.OUT_RIGHT) == Rectangle2D.OUT_RIGHT)
			{
				right = true;
				m_Hub.getTextDump().println("From Right");
			}
			
			if((outcode & Rectangle2D.OUT_TOP) == Rectangle2D.OUT_TOP)
			{
				bottom = true;
				m_Hub.getTextDump().println("From Bottom");
			}
			
			if((outcode & Rectangle2D.OUT_BOTTOM) == Rectangle2D.OUT_BOTTOM)
			{
				top = true;
				m_Hub.getTextDump().println("From Top");
			}*/
				switch(m_iTransformFlag)
			{
				case NW_SCALE:
				case NE_SCALE:
				case SW_SCALE:
				case SE_SCALE:	
					xscale = -1.0;
					yscale = -1.0;
				break;
				
			}*/
			
			
			double threshold = 0.0; //FLT_EPSILON;
								
		//detect zero crossings							
		if( (((target.x - center.x) > threshold) &&
			((source.x - center.x) < -threshold)) 
			||
			(((target.x - center.x)< -threshold) &&
			((source.x - center.x) > threshold)) 			
		   )
		{
			//xsign = -1.0;
		}
					
		if( (((target.y - center.y) > threshold) &&
			((source.y - center.y) < -threshold)) 
			||
			(((target.y - center.y) < -threshold) &&
			((source.y - center.y) > threshold)) 		
		   )
		{
			//ysign = -1.0;	
		}	
				
				
				// create a small box centered on current xform origin
		
		double width = 8 * vertex_radius;
		double height = width;
		
		Rectangle2 limiter = new Rectangle2();
		limiter.setRect(center.x - width / 2,
						center.y - width / 2,
						width, height);
		
		_testRect.setRect(limiter);
		
		//test mouse transition into and out of the limiter box
		
		/* Compare with previous state. m_bMouseEntered remains
		 * set until explicitly reset to FALSE later on. 
		 * 
		 */		
		
		if(m_bMouseEntered == false)
		m_bMouseEntered = 
						  ((limiter.contains(target)) & 
						  (!limiter.contains(source)));
		
		// similar explanation as above.
		
		if(m_bMouseExited == false)
		m_bMouseExited =  
						((!limiter.contains(target)) &
						 (limiter.contains(source)));
					
		/* The metric is the current radius of the vertices,
		 * the transformed bounding box must still be large
		 * enough to contain at least a single vertex (the point
		 * at which the coordinates of individual vertices are
		 * still far enough apart for them to be distinguished.)
		 */
				
		if( m_bMouseEntered | m_bMouseExited )	
		{
			//if(m_bMouseEntered)
			//m_Hub.getTextDump().println("Mouse entered");
			
			//if(m_bMouseExited)
			//m_Hub.getTextDump().println("Mouse exited");
										
			
			/* supress scaling, but preserve 
			 * potential mirroring. 
			 */
			
			// glue logic
			if((m_bMouseEntered == true) &&(m_bMouseExited == false) ||
			   (m_bMouseEntered == false) &&(m_bMouseExited == true))
			{
				/* Mouse entered, but not exited (or vice versa) 
				 * the limiting rectangle - supress scaling completely!
				 */
				xscale = yscale = 1.0;
			}
			else if(m_bMouseEntered & m_bMouseExited)
			{
				/* Mouse passed through the limiting rectangle
				 * - mirror the selection. The mirroring transform
				 * returns to normal with the next mouseDragged()
				 * event, since both m_bMouseEntered and 
				 * m_bMouseExited become FALSE.
				 * 
				 */
				//FIXME: Direction detection 
				yscale =  1.0;
				xscale = -1.0;
				
				m_bMouseEntered = m_bMouseExited = false;
			}
											
			if((xscale < 0.0) && (yscale < 0.0))
				m_mirrorMarkerText = "Mirror X/Y";
			else if(xsign < 0.0)
				m_mirrorMarkerText = "Mirror X";
			else if(ysign < 0.0)
				m_mirrorMarkerText = "Mirror Y";
				
				
				/*
		if(m_iModeFlag == TRANSLATE_SCALE_MODE)
		{
			switch(m_iTransformFlag)
			{
				
				
			}
			
		}
		else
		{
			switch(m_iTransformFlag)
			{
				//TODO: Undo transform code
				
			}
			
		}*/
		
			/**
	 * 
	 * @param scene
	 * @param editor
	 * @param selection
	 * @param type
	 * @param color
	 */
	/*
	public JVertexSelectionUndo(JAbstractScene scene,
								JAbstractEditor editor,
								Vector selection,
								int type,
								Color color)
	{
		this(scene,editor,selection,type);
		m_vertexColor = color;
	}*/
	
	/**
	 * 
	 * @param scene
	 * @param editor
	 * @param selection
	 * @param type
	 * @param xform
	 */
	/*
	public JVertexSelectionUndo(JAbstractScene scene,
								JAbstractEditor editor,
								Vector selection,
								int type,
								AffineTransform xform)
	{
		this(scene,editor,selection,type);
		
		
	}*/
			
			
	From JGenericGraphEditor.java
	
	/* Move the current selection set to the new position
	 * The selection is moved by figuring out the relative
	 * displacement of its centroid, then translating every
	 * element of the selection by that amount
	 * FIXME: Comment is nonsense!
	 */
	protected void translateSelectionByDelta(Point2 source,
											 Point2 target)
	{
		Point2 delta = new Point2(target.x - source.x,
								  target.y - source.y);
		// translate all selected objects
		VisualVertex v;
		
		for(int i=0; i < m_selectionSet.size(); i++)
		{	
			v = (VisualVertex)m_selectionSet.get(i);			
			v.translate(delta);
		}
		
		m_Scene.setChangeFlag();
	}
	
	/* Update the bounding rectangle of the selection
	 * set after changes to its contents
	 */
	protected void updateSelectionBBox()
	{
		//empty previous rectangle
		m_selectionBoundingBox.setRect(0,0,0,0);
		
		if(m_selectionSet.isEmpty())
		{
			
			return; // bail..
		}
				
		/* start with the first object in the list.
		 * This is necesaary for the bbox to be
		 * set up correctly (otherwise one corner/side
		 * will be stuck to the origin).
		 */
		
		VisualVertex v = 
			 (VisualVertex)m_selectionSet.get(0);
		
		m_selectionBoundingBox.setRect(v.getBoundingBox());
		
		// build new selecting bounding box
		for(int i = 1; i < m_selectionSet.size(); i++)
		{
			v = (VisualVertex)m_selectionSet.get(i);
						
			m_selectionBoundingBox.add(v.getBoundingBox());
		}
		
	}
	
	protected void selectVertices()
	{
		Enumeration vts = m_Scene.getVertices();
		
		VisualVertex v;
		
		// deselect previous set
		while(vts.hasMoreElements())
		{
			v  = (VisualVertex)vts.nextElement();
			v.deselect();
		}
		m_selectionSet.clear();
		
		// select new set
		vts = m_Scene.getVertices();
				
		while(vts.hasMoreElements())
		{
			v  = (VisualVertex)vts.nextElement();
			
			if(m_selectorBox.contains(v.getBoundingBox()))
			{				
				v.select();
				m_selectionSet.add(v);
			}
		}
		
		updateSelectionBBox();
	}
	
	protected void deselectVertices()
	{		
		VisualVertex v;
		Enumeration vts = m_selectionSet.elements();
		
		// deselect previous set
		while(vts.hasMoreElements())
		{
			v  = (VisualVertex)vts.nextElement();
			v.deselect();
		}
		
		m_selectionSet.clear();
		updateSelectionBBox();
	}
	
	protected void deleteSelection()
	{	
		Enumeration e = m_selectionSet.elements();
		
		VisualVertex v;
		
		while(e.hasMoreElements())
		{
			v = (VisualVertex)e.nextElement();			
			m_Scene.removeVertex(v);
			
		}
			
		/* The references to selected elements that have just
		 * been removed from the graph are also contained in the 
		 * selection set itself, so they have to be removed from
		 * it as well. Hence the call to deselectVertices() !
		 */
		deselectVertices();
		m_Scene.setChangeFlag();
	}
	
	//m_vertexSelection.selectVertices();
					
					//m_vertexSelection.mouseReleased(event);
					/* use new selection rectangle to
					 * select objects
					 */	
					//HACK: temporarily disabled
					/*
					selectVertices();					
					fireGraphEditorEvent(this, m_selectionSet,
					VERTEX_SELECTION_CHANGED);*/
					
					
					/**
     * 
     * 
     * <b>WARNING</b>:There is an inherent loss of precision here due to
     * casting from <code><b>double</b></code> to <code><b>float</b></code>!
     * 
     * @param x
     * @param y
     * 
     * @return
     */
    public Point2 getPointAt(double x, double y)
    {
        return getPointAt((float)x, (float)y);
    }
    
    //*************************************************************************		
		
		